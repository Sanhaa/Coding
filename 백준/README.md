### 문제 정리
- [x] [BOJ 9372: 상근이의여행](https://www.acmicpc.net/problem/9372): BFS나 DFS를 쓰려고 했는데 그냥 노드가 N개 있을 때 모든 노드를 연결하려면 최소 N-1 개의 간선이 필요하다는 것만 알면된다.
   - **75 min**
  - 그럼에도 헤맸던 이유가 '비행기를 탄다'고 표현하니까 a->b 와 b->a 왔다 갔다하면 두 번 비행기를 타는 거 아닌가? 싶었는데 그냥 비행기의 종류를 구하는거라서 방향 상관없이 간선 개수만 구하면 된다.
  - 모든 도시가 연결되어 있음을 보장한다는 문제 조건이 있기 때문에 최소 신장 트리(MST)를 찾고 간선 개수를 구하면 된다.
  - MST를 직접 구할 필요 없이 간선 개수는 항상 N-1개이므로 `N-1`만 출력하면 된다.  
- [x] [BOJ 14503: 로봇청소기](https://www.acmicpc.net/problem/14503): 
  - **50 min**
  - **`DFS` + 방향 전환**
  - 네 방향 모두 청소할 수 없을 때 후진하거나 정지 -> `while()`로 네 방향 탐색하고 나와서 `if(네 방향 불가)` 조건을 한 번 더 해줘야 했음
- [X] [BOJ 12100: 2048(Easy)](https://www.acmicpc.net/problem/14503): 
   - **3 h**
   - **`백트래킹`, `시뮬레이션`**
   - 문제 이해에도 시간이 조금 걸렸음
   - 구현할 때, 상하좌우 이동할 때 그 반대방향부터 탐색해서 합치기 + 밀기 과정 해주기
   - 이중 반복문으로 반대 방향으로 탐색하는 거 때문에 인덱스 바꾸는 거에 헤멨음
   - C언어에서 함수에 배열을 인자로 넘겨줄 때 무조건 주소값을 넘겨줌 -> vector 사용해서 복사해서 넘겨주게 함
   - 상하 / 좌우가 각각 row, col이 다르게 움직여야 해서 따로 구현했는데 잘 생각해보면 합치는 방법이 있지 않을까? --> TODO
